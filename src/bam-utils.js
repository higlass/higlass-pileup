export const ASSEMBLY_ATTR_HG38 = [
  { refName: 'chr1', length: 248956422 },
  { refName: 'chr2', length: 242193529 },
  { refName: 'chr3', length: 198295559 },
  { refName: 'chr4', length: 190214555 },
  { refName: 'chr5', length: 181538259 },
  { refName: 'chr6', length: 170805979 },
  { refName: 'chr7', length: 159345973 },
  { refName: 'chr8', length: 145138636 },
  { refName: 'chr9', length: 138394717 },
  { refName: 'chr10', length: 133797422 },
  { refName: 'chr11', length: 135086622 },
  { refName: 'chr12', length: 133275309 },
  { refName: 'chr13', length: 114364328 },
  { refName: 'chr14', length: 107043718 },
  { refName: 'chr15', length: 101991189 },
  { refName: 'chr16', length: 90338345 },
  { refName: 'chr17', length: 83257441 },
  { refName: 'chr18', length: 80373285 },
  { refName: 'chr19', length: 58617616 },
  { refName: 'chr20', length: 64444167 },
  { refName: 'chr21', length: 46709983 },
  { refName: 'chr22', length: 50818468 },
  { refName: 'chrX', length: 156040895 },
  { refName: 'chrY', length: 57227415 },
  { refName: 'chrM', length: 16569 },
  { refName: 'GL000008.2', length: 209709 },
  { refName: 'GL000009.2', length: 201709 },
  { refName: 'GL000194.1', length: 191469 },
  { refName: 'GL000195.1', length: 182896 },
  { refName: 'GL000205.2', length: 185591 },
  { refName: 'GL000208.1', length: 92689 },
  { refName: 'GL000213.1', length: 164239 },
  { refName: 'GL000214.1', length: 137718 },
  { refName: 'GL000216.2', length: 176608 },
  { refName: 'GL000218.1', length: 161147 },
  { refName: 'GL000219.1', length: 179198 },
  { refName: 'GL000220.1', length: 161802 },
  { refName: 'GL000221.1', length: 155397 },
  { refName: 'GL000224.1', length: 179693 },
  { refName: 'GL000225.1', length: 211173 },
  { refName: 'GL000226.1', length: 15008 },
  { refName: 'KI270302.1', length: 2274 },
  { refName: 'KI270303.1', length: 1942 },
  { refName: 'KI270304.1', length: 2165 },
  { refName: 'KI270305.1', length: 1472 },
  { refName: 'KI270310.1', length: 1201 },
  { refName: 'KI270311.1', length: 12399 },
  { refName: 'KI270312.1', length: 998 },
  { refName: 'KI270315.1', length: 2276 },
  { refName: 'KI270316.1', length: 1444 },
  { refName: 'KI270317.1', length: 37690 },
  { refName: 'KI270320.1', length: 4416 },
  { refName: 'KI270322.1', length: 21476 },
  { refName: 'KI270329.1', length: 1040 },
  { refName: 'KI270330.1', length: 1652 },
  { refName: 'KI270333.1', length: 2699 },
  { refName: 'KI270334.1', length: 1368 },
  { refName: 'KI270335.1', length: 1048 },
  { refName: 'KI270336.1', length: 1026 },
  { refName: 'KI270337.1', length: 1121 },
  { refName: 'KI270338.1', length: 1428 },
  { refName: 'KI270340.1', length: 1428 },
  { refName: 'KI270362.1', length: 3530 },
  { refName: 'KI270363.1', length: 1803 },
  { refName: 'KI270364.1', length: 2855 },
  { refName: 'KI270366.1', length: 8320 },
  { refName: 'KI270371.1', length: 2805 },
  { refName: 'KI270372.1', length: 1650 },
  { refName: 'KI270373.1', length: 1451 },
  { refName: 'KI270374.1', length: 2656 },
  { refName: 'KI270375.1', length: 2378 },
  { refName: 'KI270376.1', length: 1136 },
  { refName: 'KI270378.1', length: 1048 },
  { refName: 'KI270379.1', length: 1045 },
  { refName: 'KI270381.1', length: 1930 },
  { refName: 'KI270382.1', length: 4215 },
  { refName: 'KI270383.1', length: 1750 },
  { refName: 'KI270384.1', length: 1658 },
  { refName: 'KI270385.1', length: 990 },
  { refName: 'KI270386.1', length: 1788 },
  { refName: 'KI270387.1', length: 1537 },
  { refName: 'KI270388.1', length: 1216 },
  { refName: 'KI270389.1', length: 1298 },
  { refName: 'KI270390.1', length: 2387 },
  { refName: 'KI270391.1', length: 1484 },
  { refName: 'KI270392.1', length: 971 },
  { refName: 'KI270393.1', length: 1308 },
  { refName: 'KI270394.1', length: 970 },
  { refName: 'KI270395.1', length: 1143 },
  { refName: 'KI270396.1', length: 1880 },
  { refName: 'KI270411.1', length: 2646 },
  { refName: 'KI270412.1', length: 1179 },
  { refName: 'KI270414.1', length: 2489 },
  { refName: 'KI270417.1', length: 2043 },
  { refName: 'KI270418.1', length: 2145 },
  { refName: 'KI270419.1', length: 1029 },
  { refName: 'KI270420.1', length: 2321 },
  { refName: 'KI270422.1', length: 1445 },
  { refName: 'KI270423.1', length: 981 },
  { refName: 'KI270424.1', length: 2140 },
  { refName: 'KI270425.1', length: 1884 },
  { refName: 'KI270429.1', length: 1361 },
  { refName: 'KI270435.1', length: 92983 },
  { refName: 'KI270438.1', length: 112505 },
  { refName: 'KI270442.1', length: 392061 },
  { refName: 'KI270448.1', length: 7992 },
  { refName: 'KI270465.1', length: 1774 },
  { refName: 'KI270466.1', length: 1233 },
  { refName: 'KI270467.1', length: 3920 },
  { refName: 'KI270468.1', length: 4055 },
  { refName: 'KI270507.1', length: 5353 },
  { refName: 'KI270508.1', length: 1951 },
  { refName: 'KI270509.1', length: 2318 },
  { refName: 'KI270510.1', length: 2415 },
  { refName: 'KI270511.1', length: 8127 },
  { refName: 'KI270512.1', length: 22689 },
  { refName: 'KI270515.1', length: 6361 },
  { refName: 'KI270516.1', length: 1300 },
  { refName: 'KI270517.1', length: 3253 },
  { refName: 'KI270518.1', length: 2186 },
  { refName: 'KI270519.1', length: 138126 },
  { refName: 'KI270521.1', length: 7642 },
  { refName: 'KI270522.1', length: 5674 },
  { refName: 'KI270528.1', length: 2983 },
  { refName: 'KI270529.1', length: 1899 },
  { refName: 'KI270530.1', length: 2168 },
  { refName: 'KI270538.1', length: 91309 },
  { refName: 'KI270539.1', length: 993 },
  { refName: 'KI270544.1', length: 1202 },
  { refName: 'KI270548.1', length: 1599 },
  { refName: 'KI270579.1', length: 31033 },
  { refName: 'KI270580.1', length: 1553 },
  { refName: 'KI270581.1', length: 7046 },
  { refName: 'KI270582.1', length: 6504 },
  { refName: 'KI270583.1', length: 1400 },
  { refName: 'KI270584.1', length: 4513 },
  { refName: 'KI270587.1', length: 2969 },
  { refName: 'KI270588.1', length: 6158 },
  { refName: 'KI270589.1', length: 44474 },
  { refName: 'KI270590.1', length: 4685 },
  { refName: 'KI270591.1', length: 5796 },
  { refName: 'KI270593.1', length: 3041 },
  { refName: 'KI270706.1', length: 175055 },
  { refName: 'KI270707.1', length: 32032 },
  { refName: 'KI270708.1', length: 127682 },
  { refName: 'KI270709.1', length: 66860 },
  { refName: 'KI270710.1', length: 40176 },
  { refName: 'KI270711.1', length: 42210 },
  { refName: 'KI270712.1', length: 176043 },
  { refName: 'KI270713.1', length: 40745 },
  { refName: 'KI270714.1', length: 41717 },
  { refName: 'KI270715.1', length: 161471 },
  { refName: 'KI270716.1', length: 153799 },
  { refName: 'KI270717.1', length: 40062 },
  { refName: 'KI270718.1', length: 38054 },
  { refName: 'KI270719.1', length: 176845 },
  { refName: 'KI270720.1', length: 39050 },
  { refName: 'KI270721.1', length: 100316 },
  { refName: 'KI270722.1', length: 194050 },
  { refName: 'KI270723.1', length: 38115 },
  { refName: 'KI270724.1', length: 39555 },
  { refName: 'KI270725.1', length: 172810 },
  { refName: 'KI270726.1', length: 43739 },
  { refName: 'KI270727.1', length: 448248 },
  { refName: 'KI270728.1', length: 1872759 },
  { refName: 'KI270729.1', length: 280839 },
  { refName: 'KI270730.1', length: 112551 },
  { refName: 'KI270731.1', length: 150754 },
  { refName: 'KI270732.1', length: 41543 },
  { refName: 'KI270733.1', length: 179772 },
  { refName: 'KI270734.1', length: 165050 },
  { refName: 'KI270735.1', length: 42811 },
  { refName: 'KI270736.1', length: 181920 },
  { refName: 'KI270737.1', length: 103838 },
  { refName: 'KI270738.1', length: 99375 },
  { refName: 'KI270739.1', length: 73985 },
  { refName: 'KI270740.1', length: 37240 },
  { refName: 'KI270741.1', length: 157432 },
  { refName: 'KI270742.1', length: 186739 },
  { refName: 'KI270743.1', length: 210658 },
  { refName: 'KI270744.1', length: 168472 },
  { refName: 'KI270745.1', length: 41891 },
  { refName: 'KI270746.1', length: 66486 },
  { refName: 'KI270747.1', length: 198735 },
  { refName: 'KI270748.1', length: 93321 },
  { refName: 'KI270749.1', length: 158759 },
  { refName: 'KI270750.1', length: 148850 },
  { refName: 'KI270751.1', length: 150742 },
  { refName: 'KI270752.1', length: 27745 },
  { refName: 'KI270753.1', length: 62944 },
  { refName: 'KI270754.1', length: 40191 },
  { refName: 'KI270755.1', length: 36723 },
  { refName: 'KI270756.1', length: 79590 },
  { refName: 'KI270757.1', length: 71251 },
];

export const PILEUP_COLORS = {
  BG: [0.89, 0.89, 0.89, 1], // gray for the read background
  BG2: [0.85, 0.85, 0.85, 1], // used as alternating color in the read counter band
  BG_MUTED: [0.92, 0.92, 0.92, 1], // coverage background, when it is not exact
  A: [0, 0, 1, 1], // blue for A
  C: [1, 0, 0, 1], // red for c
  G: [0, 1, 0, 1], // green for g
  T: [1, 1, 0, 1], // yellow for T
  S: [0, 0, 0, 0.4], // lighter grey for soft clipping
  H: [0, 0, 0, 0.5], // darker grey for hard clipping
  X: [0, 0, 0, 0.7], // black for unknown
  I: [1, 0, 1, 0.5], // purple for insertions
  D: [1, 0.5, 0.5, 0.5], // pink-ish for deletions
  N: [1, 1, 1, 1],
  LARGE_INSERT_SIZE: [1, 0, 0, 1], // Red for read pairs with large insert size
  SMALL_INSERT_SIZE: [0, 0.24, 0.48, 1], // Dark blue for read pairs with small insert size
  LL: [0.15, 0.75, 0.75, 1], // cyan for Left-Left reads (see https://software.broadinstitute.org/software/igv/interpreting_pair_orientations)
  RR: [0.18, 0.24, 0.8, 1], // darker blue for Right-Right reads
  RL: [0, 0.5, 0.02, 1], // darker green for Right-Left reads
  WHITE: [1, 1, 1, 1],
  BLACK: [0, 0, 0, 1],
  BLACK_05: [0, 0, 0, 0.5],
  PLUS_STRAND: [0.75, 0.75, 1, 1],
  MINUS_STRAND: [1, 0.75, 0.75, 1],
  MM_M6A_FOR: [0.4, 0.2, 0.6, 1], // purple for m6A methylation events
  MM_M6A_REV: [0.4, 0.2, 0.6, 1], // purple for m6A methylation events
  MM_M5C_FOR: [1, 0, 0, 1], // red for CpG events
  MM_M5C_REV: [1, 0, 0, 1], // red for CpG events
  MM_HM5C_FOR: [1, 0.6, 0.2, 1], // purple for 5hmC events
  MM_HM5C_REV: [1, 0.6, 0.2, 1], // purple for 5hmC events
  HIGHLIGHTS_CG: [0.95, 0.84, 0.84, 1], // CG highlights
  HIGHLIGHTS_A: [0.95, 0.89, 0.71, 1], // A highlights
  HIGHLIGHTS_T: [0.95, 0.89, 0.71, 1], // T highlights
  HIGHLIGHTS_G: [0.95, 0.84, 0.84, 1], // G highlights
  HIGHLIGHTS_C: [0.95, 0.84, 0.84, 1], // C highlights
  HIGHLIGHTS_MZEROA: [0.89, 0.84, 0.96, 1], // m0A highlights
  INDEX_DHS_BG: [0, 0, 0, 0],
  FIRE_SEGMENT_BG: [0, 0, 0, 0],
  FIRE_BG: [0.25, 0.25, 0.25],
  TFBS_SEGMENT_BG: [0, 0, 0, 1],
  TFBS_BG: [1, 1, 1, 1],
  GENERIC_BED_SEGMENT_BG: [0, 0, 0, 1],
  GENERIC_BED_SEGMENT_RED_BG: [1, 0, 0, 1],
  "FIRE_169,169,169": [0.66, 0.66, 0.66],
  "FIRE_147,112,219": [0.58, 0.44, 0.86],
  "FIRE_255,0,0": [1, 0, 0],
  "FIRE_200,0,0": [0.78, 0, 0],
  "FIRE_255,140,0": [1, 0.55, 0],
  "FIRE_175,0,0": [0.68, 0, 0],
  "FIRE_225,0,0": [0.88, 0, 0],
  "FIRE_139,0,0": [0.54, 0, 0],
};

export let PILEUP_COLOR_IXS = {};
Object.keys(PILEUP_COLORS).map((x, i) => {
  PILEUP_COLOR_IXS[x] = i;
  return null;
});

export function replaceColorIdxs(newColorIdxs) {
  PILEUP_COLOR_IXS = newColorIdxs;
}

export function appendColorIdxs(newColorIdxs) {
  const currentColorTableLength = Object.keys(PILEUP_COLOR_IXS).length;
  Object.keys(newColorIdxs).map((x, i) => { newColorIdxs[x] = i + currentColorTableLength; })
  PILEUP_COLOR_IXS = {...PILEUP_COLOR_IXS, ...newColorIdxs};
}

export const hexToRGBRawTriplet = (hex) => {
  hex = hex.toUpperCase();
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return `${r},${g},${b}`;
}

export const genericBedColors = (options) => {
  if (!options.genericBed) return {};
  const colorTable = {};
  colorTable['GENERIC_BED_BG'] = [0, 0, 0, 0], // Generic BED background default
  // Object.entries(options.genericBed.colors).map((o) => {
  //   const c = o[0];
  //   console.log(`c ${c}`);
  //   const v = c.split(',').map(d => parseFloat((parseFloat(d)/255).toFixed(2)));
  //   colorTable[`GENERIC_BED_${c}`] = [...v, 1.0];
  // });
  options.genericBed.colors.forEach((c, i) => {
    // console.log(`c ${c} | i ${i}`);
    const v = c.split(',').map(d => parseFloat((parseFloat(d)/255).toFixed(2)));
    colorTable[`GENERIC_BED_${c}`] = [...v, 1.0];
  });
  // console.log(`colorTable ${JSON.stringify({...PILEUP_COLORS, ...colorTable})}`);
  return {...PILEUP_COLORS, ...colorTable};
}

export const indexDHSColors = (options) => {
  if (!options.indexDHS) return {};
  // console.log(`options ${JSON.stringify(options)}`);
  // console.log(`options.indexDHS.itemRGBMap ${JSON.stringify(options.indexDHS.itemRGBMap)}`);
  const colorTable = {};
  colorTable['INDEX_DHS_BG'] = [0, 0, 0, 0], // Index DHS background default
  Object.entries(options.indexDHS.itemRGBMap).map((o) => {
    const k = o[0];
    // const v = o[1];
    const v = k.split(',').map(d => parseFloat((parseFloat(d)/255).toFixed(2)));
    colorTable[`INDEX_DHS_${k}`] = [...v, 1.0];
  });
  // console.log(`colorTable ${JSON.stringify(colorTable)}`);
  return {...PILEUP_COLORS, ...colorTable};
};

export const fireColors = (options) => {
  if (!options.fire) return {};
  // console.log(`options.fire ${JSON.stringify(options.fire)}`);
  const colorTable = {};
  colorTable['FIRE_BG_TEST'] = [0.89, 0.89, 0.89, 1], // FIRE background default
  Object.entries(options.fire.metadata.itemRGBMap).map((o) => {
    const k = o[0];
    // const v = o[1];
    const v = k.split(',').map(d => parseFloat((parseFloat(d)/255).toFixed(2)));
    colorTable[`FIRE_${k}`] = [...v, 1.0];
  });
  // console.log(`colorTable ${JSON.stringify(colorTable)}`);
  return {...PILEUP_COLORS, ...colorTable};
};

export const ftFireColors = (options) => {
  if (!options.ftFire) return {};
  // console.log(`options.ftFire ${JSON.stringify(options.ftFire)}`);
  const colorTable = {};
  colorTable['FIRE_BG_TEST'] = [0.89, 0.89, 0.89, 1], // FIRE background default
  Object.entries(options.ftFire.metadata.itemRGBMap).map((o) => {
    const k = o[0];
    // const v = o[1];
    const v = k.split(',').map(d => parseFloat((parseFloat(d)/255).toFixed(2)));
    colorTable[`FIRE_${k}`] = [...v, 1.0];
  });
  // console.log(`colorTable ${JSON.stringify(colorTable)}`);
  return {...PILEUP_COLORS, ...colorTable};
};

export const cigarTypeToText = (type) => {
  if (type === 'D') {
    return 'Deletion';
  } else if (type === 'S') {
    return 'Soft clipping';
  } else if (type === 'H') {
    return 'Hard clipping';
  } else if (type === 'I') {
    return 'Insertion';
  } else if (type === 'N') {
    return 'Skipped region';
  }

  return type;
};

export const posToChrPos = (pos, chromsizes) => {
  // Convert an absolute genomic position to a chromosome
  // position. The chromsizes array should be an array of [chrom, size]
  // tuples

  // assume the position is 1-based

  for (let i = 0; i < chromsizes.length; i++) {
    if (pos <= chromsizes[i][1]) {
      return [chromsizes[i][0], pos];
    }

    pos -= chromsizes[i][1];
  }

  throw new Error('Position extends beyond chromsizes');
};

export const parseMD = (mdString, useCounts) => {
  let currPos = 0;
  let currNum = 0;
  let deletionEncountered = false;
  let bamSeqShift = 0;
  const substitutions = [];

  for (let i = 0; i < mdString.length; i++) {
    if (mdString[i].match(/[0-9]/g)) {
      // a number, keep on going
      currNum = currNum * 10 + +mdString[i];
      deletionEncountered = false;
    } else if (mdString[i] === '^') {
      deletionEncountered = true;
    } else {
      currPos += currNum;

      if (useCounts) {
        substitutions.push({
          length: currNum,
          type: mdString[i],
        });
      } else if (deletionEncountered) {
        // Do nothing if there is a deletion and keep on going.
        // Note that there can be multiple deletions "^ATC"
        // Deletions are visualized using the CIGAR string
        // However, keep track of where in the bam seq we need to pull the variant.
        bamSeqShift -= 1;
      } else {
        substitutions.push({
          pos: currPos,
          base: mdString[i],
          length: 1,
          bamSeqShift,
        });
      }

      currNum = 0;
      currPos += 1;
    }
  }

  return substitutions;
};

// IUPAC degeneracies, to follow SAM specification
const iupacComplementOf = {
  'A' : 'T',
  'C' : 'G', 
  'G' : 'C', 
  'T' : 'A',
  'U' : 'A',
  'Y' : 'R',
  'R' : 'Y',
  'S' : 'S',
  'W' : 'W', 
  'K' : 'M',
  'M' : 'K',
  'B' : 'V',
  'V' : 'B',
  'D' : 'H',
  'H' : 'D',
  'N' : 'N',
};

const getAllIndicesOfBaseValue = (arr, val) => {
  let indices = [], i;
  for (let i = 0; i < arr.length; ++i) {
    if (arr[i] === val) {
      indices.push(i);
    }
  }
  return indices;
}

/**
 * Builds an array of all methylations in the segment, represented
 * as offsets from the 5' end of the sequence, using data available
 * in the read's MM and ML tags
 * 
 * ref. https://samtools.github.io/hts-specs/SAMtags.pdf
 * 
 * @param  {String} segment  Current segment
 * @param  {String} seq   Read sequence from bam file.
 * @param  {Boolean} alignCpGEvents  Align stranded CpG events at the methylation offset level.
 * @return {Array}  Methylation offsets.
 */
export const getMethylationOffsets = (segment, seq, alignCpGEvents) => {
  let methylationOffsets = [];
  const moSkeleton = {
    "unmodifiedBase" : "",
    "code" : "",
    "strand" : "",
    "offsets" : [],
    "probabilities" : [],
  };

  if (segment.MM && segment.ML) {
    let currentOffsetCount = 0;
    const baseModifications = segment.MM.split(';');
    // const baseProbabilities = segment.ML.split(','); // pre-v3 bam-js API
    const baseProbabilities = (typeof segment.ML === 'string') ? Array.from(segment.ML.split(','), (d) => parseInt(d)) : (typeof segment.ML === 'number') ? [parseInt(segment.ML)] : (Array.isArray(segment.ML)) ? segment.ML : [];
    baseModifications.forEach((bm) => {
      if (bm.length === 0) return;
      const mo = Object.assign({}, moSkeleton);
      const elems = bm.split(',');
      mo.unmodifiedBase = elems[0].charAt(0);
      mo.strand = elems[0].charAt(1);
      mo.code = elems[0].charAt(2);
      const nOffsets = elems.length - 1;
      const offsets = new Array(nOffsets);
      const probabilities = new Array(nOffsets);
      const baseIndices = (segment.strand === '+') ? getAllIndicesOfBaseValue(seq, mo.unmodifiedBase) : getAllIndicesOfBaseValue(seq, iupacComplementOf[mo.unmodifiedBase]);

      //
      // build initial list of raw offsets
      //
      let offset = 0;
      if (segment.strand === '+') {
        for (let i = 1; i < elems.length; ++i) {
          const d = parseInt(elems[i]);
          offset += d;
          const strandedOffset = offset;
          const baseOffset = baseIndices[strandedOffset];
          const baseProbability = baseProbabilities[i - 1 + currentOffsetCount];
          offsets[i - 1] = baseOffset;
          probabilities[i - 1] = baseProbability;
          offset += 1;
        }
      }
      else {
        for (let i = 1; i < elems.length; ++i) {
          const d = parseInt(elems[i]);
          offset += d;
          const strandedOffset = baseIndices.length - offset - 1;
          const baseOffset = baseIndices[strandedOffset];
          const baseProbability = baseProbabilities[i - 1 + currentOffsetCount];
          offsets[nOffsets - i] = baseOffset; // reverse
          probabilities[nOffsets - i] = baseProbability;
          offset += 1;
        }
      }

      //
      // shift reverse-stranded CpG events upstream by one bases
      //
      // console.log(`alignCpGEvents ${alignCpGEvents}`);
      // if (mo.unmodifiedBase === 'C' && segment.strand === '-' && alignCpGEvents) {
      //   for (let i = 0; i < nOffsets; ++i) {
      //     offsets[i] -= 1;
      //   }
      // }

      //
      // modify raw offsets with CIGAR/substitution data
      //
      let offsetIdx = 0;
      let offsetModifier = 0;
      let clipLength = 0;
      const modifiedOffsets = new Array();
      const modifiedProbabilities = new Array();

      for (const sub of segment.substitutions) {
        //
        // if the read starts or ends with soft or hard clipping
        //
        if ((sub.type === 'S') || (sub.type === 'H')) {
          offsetModifier -= sub.length;
          clipLength = sub.length;
        }
        //
        // walk through offsets and include those less than the current substitution position
        //
        else if ((sub.type === 'M') || (sub.type === '=')) {
          while ((offsets[offsetIdx] + offsetModifier) < (sub.pos + sub.length)) {
            if ((offsets[offsetIdx] + offsetModifier) >= sub.pos) {
              modifiedOffsets.push(offsets[offsetIdx] + offsetModifier - clipLength);
              modifiedProbabilities.push(probabilities[offsetIdx]);
            }
            offsetIdx++;
          }
        }
        //
        // filter out mismatches, else modify the offset padding
        //
        else if (sub.type === 'X') {
          if ((offsets[offsetIdx] + offsetModifier) === sub.pos) {
            offsetIdx++;
          }
        }
        //
        // handle substitution operations
        //
        else if (sub.type === 'D') {
          offsetModifier += sub.length;
        }
        else if (sub.type === 'I') {
          offsetModifier -= sub.length;
        }
        else if (sub.type === 'N') {
          offsetModifier += sub.length;
        }
        //
        // if the read ends with soft or hard clipping
        //
        if ((sub.type === 'S') || (sub.type === 'H')) {
          offsetModifier += sub.length;
        }
      };

      mo.offsets = modifiedOffsets;
      mo.probabilities = modifiedProbabilities;

      // if (mo.unmodifiedBase === 'A') {
      //   console.log(`segment.substitutions ${JSON.stringify(segment.substitutions, null, 2)}`); 
      //   console.log(`${JSON.stringify(actions)}`);
      // }
      
      methylationOffsets.push(mo);
      currentOffsetCount += nOffsets;
    });
  }

  // console.log(`methylationOffsets ${JSON.stringify(methylationOffsets, null, 2)}`);

  return methylationOffsets;
}

export const mapFibertoolsFIREProbabilityToFDR = (mspProbability) => {
  return 100.0 - ((parseFloat(mspProbability) / 255.0) * 100.0);
}

/**
 * https://github.com/fiberseq/fibertools-rs/blob/8f5cfc367759c8fa94285730e534143929367be1/src/lib.rs#L38-L48
 */
export const fibertoolsFIRELinkerColor = '147,112,219';
export const fibertoolsFIRENucleosomeProbability = -255.0;
export const fibertoolsFIRENucleosomeColor = '169,169,169';
export const mapFibertoolsFIREFDRToColor = (fdr) => {
  if (fdr <= 1.0) return '139,0,0';
  else if (fdr <= 2.0) return '175,0,0';
  else if (fdr <= 3.0) return '200,0,0';
  else if (fdr <= 4.0) return '225,0,0';
  else if (fdr <= 5.0) return '255,0,0';
  else if (fdr <= 10.0) return '255,140,0';
  else if (fdr <= 25.0) return '225,225,0';
  else if (fdr <= 100.0) return fibertoolsFIRELinkerColor;
  else if (fdr <= 200.0) return fibertoolsFIRENucleosomeColor;
  else return fibertoolsFIRELinkerColor;
}

/**
 * Builds an array of all fibertools FIRE nucs in the segment, represented
 * as offsets from the 5' end of the sequence, using data available
 * in the read's 'ns' and 'nl' tags
 * 
 * ref. https://samtools.github.io/hts-specs/SAMtags.pdf
 * 
 * @param  {String} segment  Current segment
 * @return {Array}  Nucleosome offsets.
 */
export const getFibertoolsFIRENucleosomeOffsets = (segment) => {
  let nucOffsets = [];
  const noSkeleton = {
    "strand": "+",
    "offsets": [],
    "lengths": [],
    // "probabilities": [],
    // "fdrs": [],
    "colors": [],
    "offsetModifiers": [],
    "clipLength": 0,
  };

  if (segment.ns && segment.nl) {
    let currentOffsetCount = 0;
    const nucStarts = (typeof segment.ns === 'string') ? Array.from(segment.ns.split(','), (d) => parseInt(d)) : (typeof segment.ns === 'number') ? [parseInt(segment.ns)] : (Array.isArray(segment.ns)) ? segment.ns : [];
    const nucLengths = (typeof segment.nl === 'string') ? Array.from(segment.nl.split(','), (d) => parseInt(d)) : (typeof segment.nl === 'number') ? [parseInt(segment.nl)] : (Array.isArray(segment.nl)) ? segment.nl : [];
    if (nucStarts.length !== nucLengths.length) {
      console.warn(`FIRE nucleosome arrays are inconsistent | segment.readName ${segment.readName}`);
      console.warn(`                                        | segment.ns ${segment.ns}`);
      console.warn(`                                        | segment.nl ${segment.nl}`);
      return nucOffsets;
    }
    if (nucStarts.length === 0) return nucOffsets;
    const no = Object.assign({}, noSkeleton);
    no.strand = segment.strand;
    const nOffsets = nucStarts.length;
    const offsets = new Array(nOffsets);
    const lengths = new Array(nOffsets);
    const probabilities = new Array(nOffsets);
    const fdrs = new Array(nOffsets);
    const colors = new Array(nOffsets);
    if (segment.strand === '+') {
      for (let i = 0; i < nOffsets; ++i) {
        const nucStart = nucStarts[i];
        const nucLength = nucLengths[i];
        const nucProbability = fibertoolsFIRENucleosomeProbability;
        offsets[i] = nucStart;
        lengths[i] = nucLength;
        probabilities[i] = nucProbability;
        fdrs[i] = mapFibertoolsFIREProbabilityToFDR(probabilities[i]);
        colors[i] = mapFibertoolsFIREFDRToColor(fdrs[i]);
      }
    }
    else {
      for (let i = 0; i < nOffsets; ++i) {
        const strandedOffset = segment.length - nucStarts[i] - nucLengths[i];
        const nucStart = strandedOffset;
        const nucLength = nucLengths[i];
        const nucProbability = fibertoolsFIRENucleosomeProbability;
        const strandedIdx = nOffsets - i - 1;
        offsets[strandedIdx] = nucStart;
        lengths[strandedIdx] = nucLength;
        probabilities[strandedIdx] = nucProbability;
        fdrs[strandedIdx] = mapFibertoolsFIREProbabilityToFDR(nucProbability);
        colors[strandedIdx] = mapFibertoolsFIREFDRToColor(fdrs[strandedIdx]);
      }
    }

    const logModifier  = (segment.readName === '06318b68-46f6-4aa3-a5b3-8b7bad735eb8');

    // if (segment.strand === '-') {
    //   segment.substitutions.reverse();
    //   let totalSoftClipLength = 0;
    //   let startSoftClipLength = 0;
    //   for (let i = 0; i < segment.substitutions.length; ++i) {
    //     const sub = segment.substitutions[i];
    //     if (sub.type === 'S') {
    //       totalSoftClipLength += sub.length;
    //       if (i === 0) {
    //         startSoftClipLength = sub.length;
    //       }
    //     }
    //   }
    //   for (let i = 0; i < segment.substitutions.length; ++i) {
    //     const sub = segment.substitutions[i];
    //     if (sub.type === 'S') {
    //       sub.pos = (sub.pos === -sub.length) ? 0 : -sub.length;
    //     }
    //     else {
    //       sub.pos = segment.length - sub.pos - sub.length + 1 + startSoftClipLength;
    //     }
    //   }
    // }

    //
    // modify raw offsets with CIGAR/substitution data
    //
    let offsetIdx = 0;
    let offsetModifier = 0;
    let clipLength = 0;
    const modifiedOffsets = new Array();
    const modifiedLengths = new Array();
    // const modifiedProbabilities = new Array();
    // const modifiedFDRs = new Array();
    const modifiedColors = new Array();
    const offsetModifiers = new Array();

    for (const sub of segment.substitutions) {
      if (logModifier) console.log(`sub ${JSON.stringify(sub)}`);
      //
      // if the read starts or ends with soft or hard clipping
      //
      if ((sub.type === 'S') || (sub.type === 'H')) {
        offsetModifier -= sub.length;
        clipLength = sub.length;
        if (modifiedLengths.length > 0) { modifiedLengths[modifiedLengths.length - 1] -= sub.length; }
        // if (offsetModifiers.length > 0) { offsetModifiers[offsetModifiers.length - 1] = offsetModifier; }
      }
      //
      // walk through offsets and include those less than the current substitution position
      //
      else if ((sub.type === 'M') || (sub.type === '=')) {
        while ((offsets[offsetIdx] + offsetModifier) < (sub.pos + sub.length)) {
          if ((offsets[offsetIdx] + offsetModifier) >= sub.pos) {
            if (logModifier) console.log(` --> pushing offset idx ${offsetIdx} | offset ${offsets[offsetIdx]} | offsetModifier ${offsetModifier} | clipLength ${clipLength}`);
            modifiedOffsets.push(offsets[offsetIdx] + offsetModifier - clipLength);
            modifiedLengths.push(lengths[offsetIdx]);
            modifiedColors.push(colors[offsetIdx]);
            offsetModifiers.push(offsetModifier);
          }
          offsetIdx++;
        }
      }
      //
      // filter out mismatches, else modify the offset padding
      //
      else if (sub.type === 'X') {
        if ((offsets[offsetIdx] + offsetModifier) === sub.pos) {
          offsetIdx++;
        }
      }
      //
      // handle substitution operations
      //
      else if (sub.type === 'D') {
        offsetModifier += sub.length;
        modifiedLengths[modifiedLengths.length - 1] += sub.length;
        // offsetModifiers[offsetModifiers.length - 1] = offsetModifier;
      }
      else if (sub.type === 'I') {
        offsetModifier -= sub.length;
        modifiedLengths[modifiedLengths.length - 1] -= sub.length;
        // offsetModifiers[offsetModifiers.length - 1] = offsetModifier;
      }
      else if (sub.type === 'N') {
        offsetModifier += sub.length;
        modifiedLengths[modifiedLengths.length - 1] += sub.length;
        // offsetModifiers[offsetModifiers.length - 1] = offsetModifier;
      }
      //
      // if the read ends with soft or hard clipping
      //
      if ((sub.type === 'S') || (sub.type === 'H')) {
        offsetModifier += sub.length;
        if (modifiedLengths.length > 0) { modifiedLengths[modifiedLengths.length - 1] += sub.length; }
        // if (offsetModifiers.length > 0) { offsetModifiers[offsetModifiers.length - 1] = offsetModifier; }
      }

      if (logModifier) console.log(`offsetIdx ${offsetIdx} | offsetModifier ${offsetModifier} | clipLength ${clipLength}`);
    }

    no.offsets = modifiedOffsets;
    no.lengths = modifiedLengths;
    // no.probabilities = modifiedProbabilities;
    // no.fdrs = modifiedFDRs;
    no.colors = modifiedColors;
    no.offsetModifiers = offsetModifiers;
    no.clipLength = clipLength;

    nucOffsets.push(no);
    currentOffsetCount += nOffsets;
  }

  // console.log(`nucOffsets ${JSON.stringify(nucOffsets, null, 2)}`);

  return nucOffsets;
}

/**
 * Builds an array of all fibertools FIRE MSPs in the segment, represented
 * as offsets from the 5' end of the sequence, using data available
 * in the read's 'as' and 'al' tags
 * 
 * ref. https://samtools.github.io/hts-specs/SAMtags.pdf
 * 
 * @param  {String} segment  Current segment
 * @return {Array}  Methylation offsets.
 */
export const getFibertoolsFIREMSPOffsets = (segment) => {
  let mspOffsets = [];
  const moSkeleton = {
    "strand": "+",
    "offsets": [],
    "lengths": [],
    // "probabilities": [],
    // "fdrs": [],
    "colors": [],
  };

  // const reverseComplementString = (str) => str.split('').reduce((reversed, character) => complementOf[character] + reversed, '');
  // const reverseString = (str) => str.split('').reduce((reversed, character) => character + reversed, '');

  // console.log(`segment.as | ${JSON.stringify(segment.as)}`);
  // console.log(`segment.al | ${JSON.stringify(segment.al)}`);

  if (segment.as && segment.al && segment.aq) {
    let currentOffsetCount = 0;
    const mspStarts = (typeof segment.as === 'string') ? Array.from(segment.as.split(','), (d) => parseInt(d)) : (typeof segment.as === 'number') ? [parseInt(segment.as)] : (Array.isArray(segment.as)) ? segment.as : [];
    // console.log(`mspStarts ${mspStarts instanceof Array} ${mspStarts.length} ${JSON.stringify(mspStarts)}`);
    const mspLengths = (typeof segment.al === 'string') ? Array.from(segment.al.split(','), (d) => parseInt(d)) : (typeof segment.al === 'number') ? [parseInt(segment.al)] : (Array.isArray(segment.al)) ? segment.al : [];
    // console.log(`mspLengths ${mspLengths instanceof Array} ${mspLengths.length} ${JSON.stringify(mspLengths)}`);
    const mspProbabilities = (typeof segment.aq === 'string') ? Array.from(segment.aq.split(','), (d) => parseInt(d)) : (typeof segment.aq === 'number') ? [parseInt(segment.aq)] : (Array.isArray(segment.aq)) ? segment.aq : [];
    // console.log(`mspProbabilities ${mspProbabilities instanceof Array} ${mspProbabilities.length} ${JSON.stringify(mspProbabilities)}`);
    if (mspStarts.length !== mspLengths.length || mspStarts.length !== mspProbabilities.length || mspLengths.length !== mspProbabilities.length) {
      console.warn(`FIRE MSP arrays are inconsistent | segment.readName ${segment.readName}`);
      console.warn(`                                 | segment.as ${segment.as}`);
      console.warn(`                                 | segment.al ${segment.al}`);
      console.warn(`                                 | segment.aq ${segment.aq}`);
      return mspOffsets;
    }
    if (mspStarts.length === 0) return mspOffsets;
    const mo = Object.assign({}, moSkeleton);
    mo.strand = segment.strand;
    const nOffsets = mspStarts.length;
    const offsets = new Array(nOffsets);
    const lengths = new Array(nOffsets);
    const probabilities = new Array(nOffsets);
    const fdrs = new Array(nOffsets);
    const colors = new Array(nOffsets);
    if (segment.strand === '+') {
      for (let i = 0; i < nOffsets; ++i) {
        const mspStart = mspStarts[i];
        const mspLength = mspLengths[i];
        const mspProbability = mspProbabilities[i];
        offsets[i] = mspStart;
        lengths[i] = mspLength;
        probabilities[i] = mspProbability;
        fdrs[i] = mapFibertoolsFIREProbabilityToFDR(mspProbability);
        colors[i] = mapFibertoolsFIREFDRToColor(fdrs[i]);
      }
    }
    else {
      for (let i = 0; i < nOffsets; ++i) {
        const strandedOffset = segment.length - mspStarts[i] - mspLengths[i];
        const mspStart = strandedOffset;
        const mspLength = mspLengths[i];
        const mspProbability = mspProbabilities[i];
        const strandedIdx = nOffsets - i - 1;
        offsets[strandedIdx] = mspStart;
        lengths[strandedIdx] = mspLength;
        probabilities[strandedIdx] = mspProbability;
        fdrs[strandedIdx] = mapFibertoolsFIREProbabilityToFDR(mspProbability);
        colors[strandedIdx] = mapFibertoolsFIREFDRToColor(fdrs[strandedIdx]);
      }
    }

    const logModifier  = (segment.readName === '92da1af7-7170-41f8-a636-9c828d98378f');

    //
    // modify raw offsets with CIGAR/substitution data
    //
    let offsetIdx = 0;
    let offsetModifier = 0;
    let clipLength = 0;
    const modifiedOffsets = new Array();
    const modifiedLengths = new Array();
    // const modifiedProbabilities = new Array();
    // const modifiedFDRs = new Array();
    const modifiedColors = new Array();

    for (const sub of segment.substitutions) {
      // if (logModifier) console.log(`sub ${JSON.stringify(sub)}`);
      //
      // if the read starts or ends with soft or hard clipping
      //
      if ((sub.type === 'S') || (sub.type === 'H')) {
        offsetModifier -= sub.length;
        clipLength = sub.length;
        if (modifiedLengths.length > 0) { modifiedLengths[modifiedLengths.length - 1] -= sub.length; }
      }
      //
      // walk through offsets and include those less than the current substitution position
      //
      else if ((sub.type === 'M') || (sub.type === '=')) {
        while ((offsets[offsetIdx] + offsetModifier) < (sub.pos + sub.length)) {
          if ((offsets[offsetIdx] + offsetModifier) >= sub.pos) {
            modifiedOffsets.push(offsets[offsetIdx] + offsetModifier - clipLength);
            modifiedLengths.push(lengths[offsetIdx]);
            // modifiedProbabilities.push(probabilities[offsetIdx]);
            // modifiedFDRs.push(fdrs[offsetIdx]);
            modifiedColors.push(colors[offsetIdx]);
          }
          offsetIdx++;
        }
      }
      //
      // filter out mismatches, else modify the offset padding
      //
      else if (sub.type === 'X') {
        if ((offsets[offsetIdx] + offsetModifier) === sub.pos) {
          offsetIdx++;
        }
      }
      //
      // handle substitution operations
      //
      else if (sub.type === 'D') {
        offsetModifier += sub.length;
        modifiedLengths[modifiedLengths.length - 1] += sub.length;
      }
      else if (sub.type === 'I') {
        offsetModifier -= sub.length;
        modifiedLengths[modifiedLengths.length - 1] -= sub.length;
      }
      else if (sub.type === 'N') {
        offsetModifier += sub.length;
        modifiedLengths[modifiedLengths.length - 1] += sub.length;
      }
      //
      // if the read ends with soft or hard clipping
      //
      if ((sub.type === 'S') || (sub.type === 'H')) {
        offsetModifier += sub.length;
        if (modifiedLengths.length > 0) { modifiedLengths[modifiedLengths.length - 1] += sub.length; }
      }

      // if (logModifier) console.log(`offsetIdx ${offsetIdx} | offsetModifier ${offsetModifier} | clipLength ${clipLength}`);
    }

    mo.offsets = modifiedOffsets;
    mo.lengths = modifiedLengths;
    // mo.probabilities = modifiedProbabilities;
    // mo.fdrs = modifiedFDRs;
    mo.colors = modifiedColors;

    mspOffsets.push(mo);
    currentOffsetCount += nOffsets;
  }

  // console.log(`mspOffsets ${JSON.stringify(mspOffsets, null, 2)}`);

  return mspOffsets;
}

/**
 * Gets an array of all substitutions in the segment
 * @param  {String} segment  Current segment
 * @param  {String} seq   Read sequence from bam file.
 * @return {Boolean} includeClippingOps  Include soft or hard clipping operations in substitutions output.
 */
export const getSubstitutions = (segment, seq, includeClippingOps, reverseCIGAROps) => {
  let substitutions = [];
  let softClippingAtReadStart = null;

  if (segment.cigar) {
    let cigarSubs = parseMD(segment.cigar, true);

    if (reverseCIGAROps) {
      cigarSubs.reverse();
    }

    let currPos = 0;

    for (const sub of cigarSubs) {
      if (includeClippingOps && ((sub.type === 'S') || (sub.type === 'H'))) {
        substitutions.push({
          pos: currPos,
          length: sub.length,
          range: [currPos + segment.start, currPos + segment.start + sub.length],
          type: sub.type,
        });
        currPos += sub.length;
      }
      else if (sub.type === 'X') {
        // sequence mismatch, no need to do anything
        substitutions.push({
          pos: currPos,
          length: sub.length,
          range: [currPos + segment.start, currPos + segment.start + sub.length],
          type: 'X',
        });
        currPos += sub.length;
      } 
      else if (sub.type === 'I') {
        substitutions.push({
          pos: currPos,
          length: sub.length,
          range: [currPos + segment.start, currPos + segment.start + sub.length],
          type: 'I',
        });
        // currPos -= sub.length;
      } 
      else if (sub.type === 'D') {
        substitutions.push({
          pos: currPos,
          length: sub.length,
          range: [currPos + segment.start, currPos + segment.start + sub.length],
          type: 'D',
        });
        currPos += sub.length;
      } 
      else if (sub.type === 'N') {
        substitutions.push({
          pos: currPos,
          length: sub.length,
          range: [currPos + segment.start, currPos + segment.start + sub.length],
          type: 'N',
        });
        currPos += sub.length;
      } 
      else if (sub.type === '=') { 
        substitutions.push({
          pos: currPos,
          length: sub.length,
          range: [currPos + segment.start, currPos + segment.start + sub.length],
          type: '=',
        });
        currPos += sub.length;
      } 
      else if (sub.type === 'M') {
        substitutions.push({
          pos: currPos,
          length: sub.length,
          range: [currPos + segment.start, currPos + segment.start + sub.length],
          type: 'M',
        });
        currPos += sub.length;
      }
      else {
        // console.log('skipping:', sub.type);
      }
    }

    const firstSub = cigarSubs[0];
    const lastSub = cigarSubs[cigarSubs.length - 1];

    // Soft clipping can happen at the beginning, at the end or both
    // positions are from the beginning of the read
    if (firstSub.type === 'S') {
      softClippingAtReadStart = firstSub;
      // soft clipping at the beginning
      substitutions.push({
        pos: -firstSub.length,
        type: 'S',
        length: firstSub.length,
      });
    }
    // soft clipping at the end
    if (lastSub.type === 'S') {
      substitutions.push({
        pos: segment.to - segment.from,
        length: lastSub.length,
        type: 'S',
      });
    }

    // Hard clipping can happen at the beginning, at the end or both
    // positions are from the beginning of the read
    if (firstSub.type === 'H') {
      substitutions.push({
        pos: -firstSub.length,
        type: 'H',
        length: firstSub.length,
      });
    }
    if (lastSub.type === 'H') {
      substitutions.push({
        pos: segment.to - segment.from,
        length: lastSub.length,
        type: 'H',
      });
    }
  }

  // if (segment.md) {
  //   const mdSubstitutions = parseMD(segment.md, false);

  //   mdSubstitutions.forEach(function (substitution) {
  //     let posStart = substitution['pos'] + substitution['bamSeqShift'];
  //     let posEnd = posStart + substitution['length'];
  //     // When there is soft clipping at the beginning,
  //     // we need to shift the position where we read the variant from the sequence
  //     // not necessary when there is hard clipping
  //     if (softClippingAtReadStart !== null) {
  //       posStart += softClippingAtReadStart.length;
  //       posEnd += softClippingAtReadStart.length;
  //     }
  //     substitution['variant'] = seq.substring(posStart, posEnd);
  //     delete substitution['bamSeqShift'];
  //   });

  //   substitutions = mdSubstitutions.concat(substitutions);
  // }

  return substitutions;
};

/**
 * Checks the track options and determines if mates need to be loaded
 */
export const areMatesRequired = (trackOptions) => {
  return (
    trackOptions.highlightReadsBy.length > 0 ||
    trackOptions.outlineMateOnHover ||
    trackOptions.viewAsPairs
  );
};

/**
 * Calculates insert size between read segements
 */
export const calculateInsertSize = (segment1, segment2) => {
  return segment1.from < segment2.from
    ? Math.max(0, segment2.from - segment1.to)
    : Math.max(0, segment1.from - segment2.to);
};